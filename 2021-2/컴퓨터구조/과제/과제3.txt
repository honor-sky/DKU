1) 먼저 52를 8bit로 나타내면 00110100 이 된다. 그리고 -52는 52의 2의 보수로 나타내면 되기 때문에 00110100의 각 bit를 바꿔 11001011로 만들고
   1을 더하면 11001100이 된다.
   52 : 00110100
   -52 : 11001100

2-1) 5 : 00000101 
    10 : 00001010
     +   
     15  00001111 

2-2) -5 : 00000101의 2의 보수 -> 11111010 +1 = 11111011 이다.
  
    -5 : 11111011 
    10 : 00001010
    +------------------   
     5 : 100000101

    8bit 표현이므로 가장 왼쪽의 1은 버려주면 00000101(5) 라는 값이 나온다. 
  
2-3) 5-10 은 5+(-10)으로 계산해준다. -10은 10의 2의 보수로 나타내주므로 00001010 -> 11110101 +1 =11110110 이다.
     
      5  : 00000101 
    -10 : 11110110
    +-------------------
     -5 :  11111011
2-4) -5-10 은 -5 + (-10)으로 계산해준다.
    
     -5  : 11111011
     -10 : 11110110
    +--------------------
    -15 :  111110001
   
    8bit 표현이므로 가장 왼쪽의 1은 버려주면 11110001(-15) 라는 값이 나온다.

3-1) 1.5를 이진법으로 전환하면 1.1(=1.1x2^0)이다. 정수부가 한자리 이므로 소수점 이동은 필요없다.
      소수점 이동이 없었기 떄문에 지수부는 2^0 인데 8bit bias 형식이기 때문에 0+127을 해주어 127 -> 01111111 이 되다.
      소수 점 아래 가수부는 23bit이므로 남는만큼 오른쪽으로 0으로 채워주면 1000 0000 0000 0000 0000 000 이 된다.
      -1.5 이므로 sign bit는 1로 표시해주면 최종적으로 1 0111 1111 1000 0000 0000 0000 0000 000 으로 표현할 수 있다.

3-2) -1/32 는 -0.03125 이다. 0.03125를 이진법으로 전환하면 0.00001 이 나온다. 
      [0.00001을 실수표현으로 바꾸면 1.0 x 2^-5 이다.
      그러면 -5+127 이므로 122인 01110000 이  지수부이고 실수부는 0이므로 23bit는 0으로 채워주면 1 01110000 00000000000000 이다. ]
      n bit는 1이고 소수점 이동이 없으므로 지수부는 01111111 이 되고, 소수점 아래 가수부는 23bit이기 때문에 
      오른쪽으로 0을 채워주면 1 0111 1111 0000 1000 0000 0000 0000 000 으로 표현할 수 있다.

4-1) 지수부는 128+2=130이고 bias 표현이므로 -127을 해주면 3이 된다. 
      [따라서 -1.M x 2^3으로 실수 표현을 할 수 있다. 실수부의 경우 0010000...0000이므로 2진수 실수표현은 결국 -1.001 x 2^3 = -1001 이므로 실제 답은 -9이다. ]
      따라서 가수부는 실제로 0010.0000000000000000000 이다. 
      따라서 정수부는 10010 이므로 18일 것이고 소수부는 0이다. sign bit가 음수이므로 답은 -18.0 이다.

4-2)  지수부가 126인데 bias 표현이므로 -127을 해주면 -1이 된다. 
       [ 따라서 2진수 실수 표현은 1.11 x 2^-1 = 0.111 이므로 십진수 표현은 0.875이다. ]
     가수부는 실제로 0.01100000000000000000000 이다. 
      따라서 0.375가 된다.

5-1) unsigned는 양수 표현만 하기 때문에 가장 작은 수는 0이고 가장 큰 수는 2^16 = 65536 이다.

5-2) - 2^16-1 -1 ~ 2^16-1 -1 범위의 숫자 표현이 가능하므로 가장 큰 수는 2^15 -1 이고 가장 작은 수는 -2^15-1 이다.

5-3) "2의 보수법"은 0을 한 번만 표현하기 때문에 가장 큰 수로  2^15-1를 표현할 수 있다. 가장 작은 수는 -2^15 으로 표현할 수 있다.

6) -64는 64의 2의 보수법으로 나타낼 수 이따. 64는 이진법으로 01000000 이다. 2의 보수를 구하려면 각 bit를 바꿔 10111111로 만들고 1을 더하여
   - 64는 11000000이 된다. 
   -64와 -64를 더하면 -64 + (-64)를 계산하면 되는데

   -64 : 11000000
   -64 : 11000000
    +-----------------
   -128:  110000000 인데 1+1을 더하면서 1 carry 가 발생하고 1+1+1을 더하며 또 1 carry가 발생한다. 
            숫자에서 온 carry와 부호에서 온 carry가 같기 때문에 overflow는 일어나지 않았기 때문에 OF는 0이다.
            연산결과가 0이 아니므로 ZF는 0이고, sign bit는 1이다.

7) 첫째. 어떤 연산들을 수행하는지에 따라 opcode가 정해지므로 operation repertoir를 고려해야 한다.
   둘째, 처리할 데이터 유형인 Data type을 고려해야 하고,
   세번째로 operand를 몇 개 가징 것이며 각각의 크기는 어떻게 정할지에 대한 instruction format을 고려해야 한다.
   네번째로 operand가 실제로 register에 저장되는데 몇개의 register를 사용할 것이며 어떻게 참조할지에 대해서 고려해야 한다.
   마지막으로 operand가 메모리에 있을 경우엔 메모리 어디에 저장할지를 지정하는 것에 대해서 생각해야 한다. (=> addressing)
8) return point, stack pointer, frame pointer를 사용한다. 돌아올 주소를 return point에 저장하고, 함수를 수행하면서 주고 받아야할 파라미터 값들을
   stack pointer를 이용해 저장한다. 또한 함수마다 호출 시 갖는 파라미터의 개수가 다른데 frame pointer를 사용해 함수 1번 호출 시 필요한 정보들이 
   어디에 저장되는지 구분할 수 있게 해준다.
   [ return address를 효율적으로 찾기 위해서 stack을 사용하거나 register에 저장할 수도 있으나 하나만 저장될 수 있기에 call이 중첩될 경우 사용이 불가능하다. 
     혹은 호출된 procedure의 첫번째 주소에 저장할 수도 있다. 하지만 이것도 중첩된 procedure call에서는 사용하기 어렵다. ]

9)  logical right shift, Arithmethic right shift 모두 한 bit씩 오른쪽으로 옮겨준다. 하지만 logical의 경우 가장 왼쪽의 빈 공간에 무조건 0을 넣어주고
    Arithmethic의 경우 가장 왼쪽의 공간에 sign 값을 그대로 다시 넣어준다.


      