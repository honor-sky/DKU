 네트워크 Layer
  - 전송측: 전송 계층의 세그먼트 + 헤드 => datagram 으로 만들고 datagram을 인접한 라우터에 전송
    수신측: 네트워크 세그먼트 추출해 전송계층으로 보냄
  - 매 호스트, 라우터마다 네트워크 프로토콜(IP)을 갖고 있다.
  - 라우터=> 패킷을 어느 경로로 보낼 것인가?(헤드 정보로 경로 설정)

하는 일
1) 포워딩 : 라우터의 입력 포트에서 출력포트로 패킷을 이동시키는 것. ex) 경유 시, 중간에 어떤 gate로 갈 것인가
   (data plan/데이터 평면)  한 라우터 안에서 어떤 경로로 들어오고 나갈 것인가
   나노초 단위로 빠르게 실행
2) 라우팅 : 전체적으로 봤을 때, A->B 최단 경로 설정 ex) 어디를 경유해서 목적지에 도달할 것인가
   (Control plane제어 평면)   1)전통적인 접근->라우터가 결정 
                                    2) SDN(software defined networking): 원격으로 관리하는 서버 존재

 => Routing과 Forwarding은 Routing Algorithm을 통해 만들어진 Forwarding table을 참조하여 
      패킷의 목적지에 알맞은 포트로 패킷을 이동시키는 것이다. (경로 및 포트 결정)

네트워크 서비스 모델
 네트워크가 제공하는 서비스
  1) 전달 보장
  2) 전송 시간 보장
  3) 순서화: 여러개의 패킷 전송 순서 지키기
  4) 최소 전송속도 보자
  5) 보안 보장

  => 인터넷에서는 사실 네트워크가 완전 보장은 X...최선만 다할뿐...(할 일 너무 많음) / 전송계층에서 맡아서 함
 
라우터 : 네트워크끼리 연결해주는 통신 장비(하드웨어) / 소프트웨어 기능도 해서 컴퓨터라고 하기도 함
           
           라우터 내부
             - 입력 포트: 라인 종단 기능/링크계층 처리를 위해 개별 입력링크와 관련된 물리 계층 및 데이터 링크 계층 구현
                             ->포워딩 테이블 이용해 스위칭 구조를 통해 전달 되는 출력 포트 검색(큐잉 사용/큐 많이 밀리면 손실)
                                1) 목적지 기반 전달: ip 주소에 따라서 결정

                                  - 들어온 패킷을 스위칭하여 출력포트로 보낼 때, 어떤 링크를 사용할지 결정해야 한다(라우터 안에서 스위치가 하는 일)
                                    목적지 주소 번호의 범위 지정해서 링크 인터페이스 4개로 나눔
                                  - 비트 프릭픽스 정해 놓고 앞에 3개의 엔트리와 대응하지 않으면 '최장 프리픽스 매칭 규칙 적용' -> 가장 긴 대응 엔트리로 보냄

                                2) 일반 전달: 헤더 정보에 따라서 결정
             - 스위칭 구조: 라우터의 입력포트와 출력 포트를 연결
                               
                                 변환기
                                      패킷을 입력 포트(입력 버퍼)에서 출력포트(출력버퍼)로 포워딩 테이블을 이용해 보내는데 이를 보내는 방식이 3가지 이싿
                                          1)메모리 방식: CPU가 일반 메모리 처리하는 방식처럼 사용/ 메모리에 패킷 가져와 헤더 정보 읽어 판단(속도 느림)
                                          2)버스 방식: 버스를 통해 바로 전송 /동시 전송이 아니라 버스 라인을 한 패킷만 사용 가능(Cisco 6500)
                                          3)크로스바 방식: 모든 경로를 사용할 수 있도록 설정(Cisco 12000)

             - 출력 포트: 패킷 저장하고 링크/물리 계층 기능 수행해 출력 링크로 전송
             - 라우팅 프로세서: 제어 평면 기능 수행(SDN)


input 큐잉 지연
 - HOL(head of the line blocking): 같은 경로를 사용하는 것이 아님에도 앞에 있는 데이터그램이 지연되어서
                                            함께 지연되는 경우
output 큐잉 지연
 - 버퍼링 존재함 / 버퍼의 사이즈 중요( RTT*C/루트 N)
 - 스케쥴링을 통해 조절 :  큐 안에 있는 어떤 것을 먼저 선택할것인가
                                   - FIFO(먼저 들어온거 먼저 보냄)
                                   - 우선순위에 따라 처리
                                   - Round Robin(RR): 돌아가면서 처리
                                   - Weighted Fair Queuing(WFQ): 적절히 클래스를 나누고 그 클래스들이 돌아가면서 처리
                                                                           (클래스 내부에선 우선순위 존재)
                                 큐 안에 쌓인 패킷을 뭘 먼저 버릴 것인가?
                                   - 늦게 들어온것/ 우선순위/랜덤으로



IP 프로토콜
 - 20byte 헤드 + data
ver:IPV4/IPV6 같은 버전
type of service: 데이터가 실시간인지 중요한 데이터인지 같은 타입 명시
length: 데이터 총길이
16-bit indentifier: 몇개의 라우터를 거치는지 예측해 값 넣어주고 하나씩 감소시킴(패킷이 미아가 되었을 경우, 0가 되면 버림)
fragment offset: 대역폭 좁아서 정보들을 쪼갰을 때 그 나눈 정보들을 저장
upper layer: 상위 layer(udp/tcp) 정보
option: 타임스탬프, 어떤 라우터 거쳐왔는지 기록
=>IPV4 포맷

IPv4  주소가 거의 고갈 => IPv6 포맷 만듬(헤더가 40byte) 
ver:IPV4/IPV6 같은 버전
pri: 패킷의 우선순위
flow label: 패킷 중 일부가 동일한 경로를 가는 경우 그것이 하나의 플로우가 됨
next hdr: 다음 헤드의 정보를 읽을 수 있음(상위 계층의 프로토콜 알려줌)
hop limit: 몇 개의 라우터를 지날지 limit 정해주고, 하나 지날 때마다 -1. 0되면 패킷 소멸(미아 패킷 관리 가능) *16-bit indentifier와 비슷한 개념
*IPv6에는 checksum이 없다 =>예전에 비해서 에러가 줄어듬(전송계층이나 링크 계층에서 에러 체크 해주는걸로 충분)
ICMPv6

tunneling: IPv4와 IPv6 호환성을 해결 (IPv6->IPv4와: IPv6에 IPv4 정보 덮입힘, IPv4->IPv6: IPv4 정보를 벗겨냄)
MTU
 - 네트워크에서 전송될 수 있는 최대 크기의 패킷 또는 프레임
 - 이게 좁으면 패킷을 쪼개고 그 정보를 fragment offset에 남겨주면 나중에 다 도착해서 지들끼리 찾아서 다시 합침

ip 주소: 32bit 식별자, 호스트/라우터/인터페이스(호스트와 물리적 링크 사이의 경계/LAN 카드)마다 부여 *라우터의 경우엔, 여러개의 LAN카드가 있을 수 있어 IP가 여러개
          4BYTE 10진수로 표현

  IP주소 체계
    - 32bit 식별자, 호스트/라우터/인터페이스(호스트와 물리적 링크 사이의 경계/LAN 카드)마다 부여
    - 네트워크(subnet:라우터의 간섭 받지 않고 패킷 주고 받을 수 있는 네트워크)+호스트
    - 호스트 id의 일부를 네트워크 id로 설정해 네트워크 관리가 쉽다
    - ICANN에서 IP주소를 관리(클래스로 관리)
    - 얼만큼이 네트워크 id이고 얼만큼이 호스트 id인지 서브넷 마스크를 통해 쉽게 알 수 있다
     *서브넷 마스크: 한 네트워크에서 네트워크는 동일하고 호스트 id만 다름. 그럼 얼마나 호스트 할당 받을 수 있는지만 보이고 나머진 가려버림
      ex) IP주소: 192.168.0.1/24 라고 하면 이는 C클래스이고 기본 디폴트 마스크는 255.255.255.0(1111 1111.1111 1111.1111 1111.0000 0000 )
      1은 네트워크 영역으로 사용하겠다는 뜻이고 0은 호스트 IP로 사용하겠다는 뜻.
      즉 사용자에게 0이 표현된 부분만 호스트 IP를 할당할 수 있게 만들겠다는 뜻입니다.
     * CIDR: 서브넷 마스크가 아니라 숫자를 사용하여 네트워크 ip의 프리픽스 정해줌
 추가공부) cidr 과 ip주소 할당 체계에 대해서 더 공부할 필요가 있음

IP의 사용(DHCP)
 - 예전엔 IP 설정 스스로 하지만 지금은 컴 켜면 자동으로ip 설정(DHCP 프로토콜: 응용계층 프로토폴/UDP를 사용)
 - 클라이언트에서 포트번호 + 브로드 캐스팅(아직 주소가 없으니까...)("거기 혹시 DHCP 서버 있으면 내게 응답 좀 해 주세요~"라는 의미) -> 서버가 인식하고 ip주소 보내줌 
   ->OK하고 받은 ip주소로 다시 request(확실하게 내가 이거 받았다, 쓸거다 확인용) -> 서버가 확정해줌
   * ip 주소 없으면 브로드캐스팅과 트랜잭션으로 찾나봄...
   * DHCP 서버가 제공하는 것
     1) 클라이언트의 IP주소 2) 클라이언트가 처음으로 만나는 라우터의 IP주소(라우터를 통해야 경로 이용 가능) 3) DNS 서버의 이름과 ip 주소
    
IP의 사용(NAT)                                          
 - 인터넷 공유기 하나에만 IP할당하고, 공유기를 통해 연결된 기기에 가상(사설) IP부여함(외부에서는 하나의 IP를 공유)
 - 내부에서는 사설 IP 사용, 외부로 나갈 때는 NAT translation table 이용해 공유기의 공식 IP 사용
 - Port Forwarding을 통해  사설 IP중 하나를 웹서버로 고정 가능




ICMP 프로토콜
 - IP 프로토콜이 관리하지 못하는 에러를 관리

[참조]
https://nenunena.tistory.com/52
https://hororolol.tistory.com/298(정리할 때 참고용)